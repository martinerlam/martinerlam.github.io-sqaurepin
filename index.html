<!DOCTYPE html>
<html lang="en">
<head>
  <!--
    RenderHeads Rod Bundle
    Version: v0.9.0
    Date: 2026-01-20

    Changes from v0.8.9:
    - Removed cap highlight idea entirely (no extra cap mesh, no end-face lighting).
    - Added REAL shadows with a single toggle: Shadows On/Off.
    - When ON:
      - renderer.shadowMap enabled
      - keyLight + fillLight cast shadows
      - rods cast shadows
      - a subtle ground plane receives shadows (can be invisible but still receive)

    Retained:
    - 2 directional lights (Key + Fill) + Ambient controls
    - Colour controls (Palette/Single + Brightness)
    - Square-ended rods, packing, thickness, 200 rods, rotation/scale, hover, audio, letter imprint, rod spin toggle.
    - UI + Logo hide/show button
  -->
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RenderHeads Rod Bundle v0.9.0</title>

  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: #0b0b0b; }
    canvas { display: block; }

    .logo{
      position: fixed;
      top: 100px;
      right: 100px;
      height: 150px;
      width: auto;
      z-index: 10000;
      opacity: 0.95;
      pointer-events: none;
    }

    .uiToggle{
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 10001;
      background: rgba(0,0,0,0.6);
      color: #fff;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 10px;
      padding: 8px 12px;
      font-size: 12px;
      cursor: pointer;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }

    .controls{
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 280px;
      max-height: 70vh;
      overflow: auto;
      background: rgba(0,0,0,0.6);
      color: #fff;
      padding: 12px 14px;
      border-radius: 10px;
      z-index: 9999;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      font-size: 12px;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }

    .controls label{ display:block; margin-top:8px; }
    .controls label:first-child{ margin-top:0; }
    .controls input[type="range"]{ width: 250px; }
    .controls select{
      width: 260px;
      margin-top: 4px;
      background: rgba(255,255,255,0.08);
      color: #fff;
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 8px;
      padding: 6px 8px;
      outline: none;
    }

    details{ margin-top:10px; }
    summary{ cursor:pointer; user-select:none; list-style:none; }
    summary::-webkit-details-marker{ display:none; }
    summary::before{ content:"▸ "; opacity:0.9; }
    details[open] summary::before{ content:"▾ "; }

    .hint{
      margin-top: 10px;
      opacity: 0.75;
      line-height: 1.35;
      font-size: 11px;
    }
  </style>
</head>

<body>
  <button id="toggleUI" class="uiToggle">Hide UI</button>
  <img src="logo.png" alt="Logo" class="logo" />

  <div class="controls">
    <label>
      Packing
      <select id="packing">
        <option value="grid">Grid</option>
        <option value="hex">Hex</option>
      </select>
    </label>

    <label>
      Mode
      <select id="renderMode">
        <option value="solid">Solid</option>
        <option value="wire">Wireframe</option>
      </select>
    </label>

    <label>
      Rod Spin
      <select id="rodSpin">
        <option value="off" selected>Off</option>
        <option value="on">On</option>
      </select>
    </label>

    <label>
      Shadows
      <select id="shadows">
        <option value="off" selected>Off</option>
        <option value="on">On</option>
      </select>
    </label>

    <label>Scale <input id="scale" type="range" min="0.2" max="2.5" step="0.01" value="1"></label>
    <label>Spacing <input id="spacing" type="range" min="0.2" max="1.5" step="0.01" value="0.5"></label>
    <label>Interaction <input id="interaction" type="range" min="0" max="2" step="0.01" value="1"></label>

    <label>
      Thickness
      <input id="diameter" type="range" min="0.04" max="0.5" step="0.005" value="0.30">
    </label>
    <label style="opacity:0.85;">
      Thickness: <span id="diameterLabel">0.30</span>
    </label>

    <label>
      Rods
      <input id="count" type="range" min="4" max="200" step="1" value="25">
    </label>
    <label style="opacity:0.85;">
      Count: <span id="countLabel">25</span>
    </label>

    <details>
      <summary>Rotation</summary>
      <label>X Rotation <input id="rotX" type="range" min="-3.14" max="3.14" step="0.01" value="0"></label>
      <label>Y Rotation <input id="rotY" type="range" min="-3.14" max="3.14" step="0.01" value="0"></label>
      <label>Z Rotation <input id="rotZ" type="range" min="-3.14" max="3.14" step="0.01" value="0"></label>
    </details>

    <details>
      <summary>Lighting</summary>
      <label>Ambient <input id="ambientIntensity" type="range" min="0" max="1.5" step="0.01" value="0.35"></label>

      <div style="margin-top:8px; opacity:0.85;">Key Light</div>
      <label>Intensity <input id="lightIntensity" type="range" min="0" max="3" step="0.01" value="1"></label>
      <label>Azimuth <input id="lightAzimuth" type="range" min="0" max="360" step="1" value="35"></label>
      <label>Elevation <input id="lightElevation" type="range" min="0" max="90" step="1" value="55"></label>

      <div style="margin-top:10px; opacity:0.85;">Fill Light</div>
      <label>Intensity <input id="fillIntensity" type="range" min="0" max="3" step="0.01" value="0.6"></label>
      <label>Azimuth <input id="fillAzimuth" type="range" min="0" max="360" step="1" value="215"></label>
      <label>Elevation <input id="fillElevation" type="range" min="0" max="90" step="1" value="25"></label>
    </details>

    <details>
      <summary>Colour</summary>
      <label>
        Colour Mode
        <select id="colorMode">
          <option value="palette" selected>Palette</option>
          <option value="single">Single</option>
        </select>
      </label>

      <label>
        Single Colour
        <input id="singleColor" type="color" value="#00b3b8"
               style="width:260px; height:34px; padding:0; border:none; background:transparent;">
      </label>

      <label>Brightness <input id="brightness" type="range" min="0.25" max="2" step="0.01" value="1"></label>
    </details>

    <label>Sound <input id="soundToggle" type="checkbox" checked style="transform: translateY(2px);"></label>

    <div class="hint">
      Hold <b>A–Z</b> or <b>0–9</b> to imprint a low-res character. Release to clear.<br/>
      Press <b>Esc</b> to clear immediately. (Click once to enable audio.)
    </div>
  </div>

  <script type="module">
    (async () => {
      const APP_VERSION = 'v0.9.0';
      console.log('RenderHeads Rod Bundle', APP_VERSION);

      // UI toggle (hide/show BOTH UI panel + logo)
      const toggleBtn = document.getElementById('toggleUI');
      const controlsEl = document.querySelector('.controls');
      const logoEl = document.querySelector('.logo');
      let uiVisible = true;

      toggleBtn.addEventListener('click', () => {
        uiVisible = !uiVisible;
        controlsEl.style.display = uiVisible ? 'block' : 'none';
        logoEl.style.display = uiVisible ? 'block' : 'none';
        toggleBtn.textContent = uiVisible ? 'Hide UI' : 'Show UI';
      });

      // Load Three.js (with friendly fallback)
      let THREE;
      try {
        THREE = await import('https://unpkg.com/three@0.160.0/build/three.module.js');
      } catch (err) {
        console.error(err);
        const msg = document.createElement('div');
        msg.style.position = 'fixed';
        msg.style.inset = '20px';
        msg.style.maxWidth = '780px';
        msg.style.background = 'rgba(0,0,0,0.78)';
        msg.style.border = '1px solid rgba(255,255,255,0.2)';
        msg.style.borderRadius = '14px';
        msg.style.padding = '16px 18px';
        msg.style.color = '#fff';
        msg.style.fontFamily = 'ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
        msg.style.zIndex = '999999';
        msg.innerHTML = `
          <div style="font-size:16px; font-weight:700; margin-bottom:8px;">Three.js failed to load</div>
          <div style="line-height:1.5; opacity:0.95;">
            If you opened this via <code>file://</code>, run it from a local server instead:<br/>
            <pre style="background:rgba(255,255,255,0.08); padding:10px; border-radius:10px; overflow:auto;">python3 -m http.server</pre>
            Then open: <code>http://localhost:8000</code>
          </div>
          <div style="margin-top:10px; opacity:0.8; font-size:12px;">Console error: ${String(err).replaceAll('<','&lt;')}</div>
        `;
        document.body.appendChild(msg);
        return;
      }

      /* ---------------- Scene ---------------- */
      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 240);
      camera.position.set(0, 2.2, 10);
      camera.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      document.body.appendChild(renderer.domElement);

      /* ---------------- Lighting ---------------- */
      const ambient = new THREE.AmbientLight(0xffffff, 0.35);
      scene.add(ambient);

      const keyLight = new THREE.DirectionalLight(0xffffff, 1.0);
      scene.add(keyLight);
      scene.add(keyLight.target);

      const fillLight = new THREE.DirectionalLight(0xffffff, 0.6);
      scene.add(fillLight);
      scene.add(fillLight.target);

      /* ---------------- Shadow receiver (ground) ----------------
         This plane is mostly invisible but gives you real contact shadows.
         If you want to actually see a surface, increase its opacity. */
      const groundGeo = new THREE.PlaneGeometry(200, 200);
      const groundMat = new THREE.ShadowMaterial({ opacity: 0.22 });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -1.2;
      ground.receiveShadow = true;
      scene.add(ground);

      /* ---------------- DOM controls ---------------- */
      const packingSelect = document.getElementById('packing');
      const renderModeSelect = document.getElementById('renderMode');
      const rodSpinSelect = document.getElementById('rodSpin');
      const shadowsSelect = document.getElementById('shadows');

      const scaleSlider = document.getElementById('scale');
      const spacingSlider = document.getElementById('spacing');
      const interactionSlider = document.getElementById('interaction');

      const diameterSlider = document.getElementById('diameter');
      const diameterLabel = document.getElementById('diameterLabel');

      const countSlider = document.getElementById('count');
      const countLabel = document.getElementById('countLabel');

      const rotXSlider = document.getElementById('rotX');
      const rotYSlider = document.getElementById('rotY');
      const rotZSlider = document.getElementById('rotZ');

      const ambientIntensitySlider = document.getElementById('ambientIntensity');

      const lightIntensitySlider = document.getElementById('lightIntensity');
      const lightAzimuthSlider = document.getElementById('lightAzimuth');
      const lightElevationSlider = document.getElementById('lightElevation');

      const fillIntensitySlider = document.getElementById('fillIntensity');
      const fillAzimuthSlider = document.getElementById('fillAzimuth');
      const fillElevationSlider = document.getElementById('fillElevation');

      const colorModeSelect = document.getElementById('colorMode');
      const singleColorInput = document.getElementById('singleColor');
      const brightnessSlider = document.getElementById('brightness');

      const soundToggle = document.getElementById('soundToggle');
      let soundEnabled = soundToggle.checked;
      soundToggle.addEventListener('change', () => { soundEnabled = soundToggle.checked; });

      /* ---------------- Rod bundle ---------------- */
      const rodGroup = new THREE.Group();
      scene.add(rodGroup);

      const rods = [];
      let rodCount = parseInt(countSlider.value, 10);
      countLabel.textContent = String(rodCount);

      let rodThickness = parseFloat(diameterSlider.value);
      diameterLabel.textContent = rodThickness.toFixed(2);

      const palette = [
        0x3fa7b5, 0x00b3b8, 0x1b9e77, 0x00a6e6,
        0xf57c00, 0xd32f2f, 0xfbc02d, 0xe91e63, 0x8e245d
      ];

      const geometry = new THREE.BoxGeometry(2, 3, 2);

      function applyRenderMode() {
        const isWire = renderModeSelect.value === 'wire';
        for (const r of rods) {
          r.material.wireframe = isWire;
          r.material.needsUpdate = true;
        }
      }

      function applyThickness() {
        const s = rodThickness / 2;
        for (const r of rods) {
          r.scale.x = s;
          r.scale.z = s;
        }
      }

      function applyColors() {
        const mode = colorModeSelect.value;
        const bright = parseFloat(brightnessSlider.value);

        if (mode === 'single') {
          const base = new THREE.Color(singleColorInput.value).multiplyScalar(bright);
          for (const r of rods) {
            r.userData.baseColor.copy(base);
            r.material.color.copy(base);
          }
        } else {
          for (const r of rods) {
            const base = new THREE.Color(palette[r.userData.idx % palette.length]).multiplyScalar(bright);
            r.userData.baseColor.copy(base);
            r.material.color.copy(base);
          }
        }
      }

      function applyShadows() {
        const on = shadowsSelect.value === 'on';

        renderer.shadowMap.enabled = on;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        keyLight.castShadow = on;
        fillLight.castShadow = on;

        ground.visible = on;         // show the shadow material plane only when needed
        ground.receiveShadow = on;

        for (const r of rods) {
          r.castShadow = on;
          r.receiveShadow = false;   // rods receiving shadows can look noisy; keep off for clarity
        }

        // Shadow quality / size (tweakable, but kept stable)
        if (on) {
          // key light shadows
          keyLight.shadow.mapSize.set(2048, 2048);
          keyLight.shadow.bias = -0.0002;
          keyLight.shadow.normalBias = 0.02;

          // fill light subtle shadows (optional)
          fillLight.shadow.mapSize.set(1024, 1024);
          fillLight.shadow.bias = -0.0002;
          fillLight.shadow.normalBias = 0.02;

          const setShadowFrustum = (light) => {
            const cam = light.shadow.camera;
            cam.near = 1;
            cam.far = 60;
            cam.left = -18;
            cam.right = 18;
            cam.top = 18;
            cam.bottom = -18;
            cam.updateProjectionMatrix();
          };
          setShadowFrustum(keyLight);
          setShadowFrustum(fillLight);
        }
      }

      /* ---------------- Letter imprint ---------------- */
      let letterMask = [];
      let letterMix = 0;
      let letterMixTarget = 0;
      let currentGlyph = '';
      let heldKey = null;

      const LETTER_AMPLITUDE = 0.9;

      const glyphCanvas = document.createElement('canvas');
      const glyphCtx = glyphCanvas.getContext('2d', { willReadFrequently: true });

      function buildLetterMask(char) {
        const gridSize = Math.ceil(Math.sqrt(rodCount));
        glyphCanvas.width = gridSize;
        glyphCanvas.height = gridSize;

        glyphCtx.clearRect(0, 0, gridSize, gridSize);
        glyphCtx.fillStyle = '#000';
        glyphCtx.fillRect(0, 0, gridSize, gridSize);

        const fontSize = gridSize * 0.9;
        glyphCtx.fillStyle = '#fff';
        glyphCtx.textAlign = 'center';
        glyphCtx.textBaseline = 'middle';
        glyphCtx.font = `900 ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
        glyphCtx.fillText(char, gridSize / 2, gridSize / 2 + gridSize * 0.05);

        const img = glyphCtx.getImageData(0, 0, gridSize, gridSize).data;
        const mask = new Array(rodCount).fill(0);

        for (let i = 0; i < rodCount; i++) {
          const row = Math.floor(i / gridSize);
          const col = i % gridSize;
          const px = (row * gridSize + col) * 4;
          mask[i] = img[px] / 255;
        }

        letterMask = mask;
      }

      function clearLetter() {
        currentGlyph = '';
        letterMixTarget = 0;
        heldKey = null;
      }

      function setLetter(char, keyId) {
        currentGlyph = char;
        heldKey = keyId;
        buildLetterMask(char);
        letterMixTarget = 1;
      }

      function isTypingInUI() {
        const el = document.activeElement;
        if (!el) return false;
        const tag = el.tagName ? el.tagName.toLowerCase() : '';
        return tag === 'input' || tag === 'select' || tag === 'textarea';
      }

      window.addEventListener('keydown', (e) => {
        if (isTypingInUI()) return;

        if (e.key === 'Escape') {
          clearLetter();
          return;
        }

        if (e.repeat) return;

        if (e.key && e.key.length === 1) {
          const k = e.key.toUpperCase();
          if ((k >= 'A' && k <= 'Z') || (k >= '0' && k <= '9')) {
            setLetter(k, e.code);
          }
        }
      });

      window.addEventListener('keyup', (e) => {
        if (!heldKey) return;
        if (e.code === heldKey) clearLetter();
      });

      /* ---------------- Layout / rebuild ---------------- */
      function layoutRods() {
        const spacing = parseFloat(spacingSlider.value);
        const packing = packingSelect.value;
        const gridSize = Math.ceil(Math.sqrt(rodCount));

        for (let i = 0; i < rods.length; i++) {
          const r = rods[i];
          let x, z;

          if (packing === 'hex') {
            const row = Math.floor(i / gridSize);
            const col = i % gridSize;
            const offset = (row % 2 === 0) ? 0 : spacing * 0.5;
            x = (col - gridSize / 2) * spacing + offset;
            z = (row - gridSize / 2) * spacing * 0.866;
          } else {
            const col = i % gridSize;
            const row = Math.floor(i / gridSize);
            x = (col - gridSize / 2) * spacing;
            z = (row - gridSize / 2) * spacing;
          }

          r.userData.basePosition.set(x, 0, z);
        }

        if (currentGlyph) buildLetterMask(currentGlyph);
      }

      function rebuildRods(newCount) {
        rodCount = Math.max(4, Math.min(200, newCount | 0));
        countSlider.value = String(rodCount);
        countLabel.textContent = String(rodCount);

        for (const r of rods) {
          if (r.material) r.material.dispose();
          rodGroup.remove(r);
        }
        rods.length = 0;

        for (let i = 0; i < rodCount; i++) {
          const rodMat = new THREE.MeshStandardMaterial({
            color: palette[i % palette.length],
            roughness: 0.5,
            metalness: 0.05,
            wireframe: renderModeSelect.value === 'wire'
          });

          const rod = new THREE.Mesh(geometry, rodMat);

          rod.userData = {
            idx: i,
            basePosition: new THREE.Vector3(),
            phase: Math.random() * Math.PI * 2,
            hoverStrength: 0,
            baseColor: new THREE.Color(palette[i % palette.length])
          };

          rods.push(rod);
          rodGroup.add(rod);
        }

        letterMask = new Array(rodCount).fill(0);
        if (currentGlyph) buildLetterMask(currentGlyph);

        applyRenderMode();
        applyThickness();
        applyColors();
        layoutRods();
        applyShadows();
      }

      /* ---------------- Lighting controls ---------------- */
      function setDirectionalFromSpherical(light, azDeg, elDeg, r) {
        const az = (azDeg * Math.PI) / 180;
        const el = (elDeg * Math.PI) / 180;

        const x = r * Math.cos(el) * Math.cos(az);
        const y = r * Math.sin(el);
        const z = r * Math.cos(el) * Math.sin(az);

        light.position.set(x, y, z);
        light.target.position.set(0, 0, 0);
      }

      function updateLights() {
        ambient.intensity = parseFloat(ambientIntensitySlider.value);

        keyLight.intensity = parseFloat(lightIntensitySlider.value);
        setDirectionalFromSpherical(
          keyLight,
          parseFloat(lightAzimuthSlider.value),
          parseFloat(lightElevationSlider.value),
          18
        );

        fillLight.intensity = parseFloat(fillIntensitySlider.value);
        setDirectionalFromSpherical(
          fillLight,
          parseFloat(fillAzimuthSlider.value),
          parseFloat(fillElevationSlider.value),
          18
        );
      }

      /* ---------------- Raycasting ---------------- */
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();

      window.addEventListener('mousemove', (event) => {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      });

      /* ---------------- Audio (Option C) ---------------- */
      let audioCtx = null;
      let lastHovered = null;

      function ensureAudio() {
        if (!soundEnabled) return null;
        const AC = window.AudioContext || window.webkitAudioContext;
        if (!AC) return null;
        if (!audioCtx) {
          try { audioCtx = new AC(); }
          catch (e) { console.warn('AudioContext init failed:', e); return null; }
        }
        if (audioCtx.state === 'suspended') audioCtx.resume().catch(() => {});
        return audioCtx;
      }

      window.addEventListener('pointerdown', () => ensureAudio(), { once: true });

      function playTone(rod) {
        const ctx = ensureAudio();
        if (!ctx || ctx.state !== 'running') return;

        const now = ctx.currentTime;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();

        const freq = 220 + (rod.userData.idx % 24) * 18;
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq, now);

        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(0.07, now + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.12);

        osc.connect(gain);
        gain.connect(ctx.destination);

        osc.start(now);
        osc.stop(now + 0.14);
      }

      /* ---------------- Resize ---------------- */
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      /* ---------------- Initial state ---------------- */
      rebuildRods(rodCount);
      updateLights();
      applyShadows(); // ensure off by default, but consistent

      /* ---------------- Listeners ---------------- */
      renderModeSelect.addEventListener('change', applyRenderMode);

      shadowsSelect.addEventListener('change', applyShadows);

      packingSelect.addEventListener('change', layoutRods);
      spacingSlider.addEventListener('input', layoutRods);

      countSlider.addEventListener('input', () => {
        rebuildRods(parseInt(countSlider.value, 10));
        lastHovered = null;
      });

      diameterSlider.addEventListener('input', () => {
        rodThickness = parseFloat(diameterSlider.value);
        diameterLabel.textContent = rodThickness.toFixed(2);
        applyThickness();
      });

      // Lighting listeners
      ambientIntensitySlider.addEventListener('input', updateLights);

      lightIntensitySlider.addEventListener('input', updateLights);
      lightAzimuthSlider.addEventListener('input', updateLights);
      lightElevationSlider.addEventListener('input', updateLights);

      fillIntensitySlider.addEventListener('input', updateLights);
      fillAzimuthSlider.addEventListener('input', updateLights);
      fillElevationSlider.addEventListener('input', updateLights);

      // Colour listeners
      colorModeSelect.addEventListener('change', applyColors);
      singleColorInput.addEventListener('input', applyColors);
      brightnessSlider.addEventListener('input', applyColors);

      /* ---------------- Animation ---------------- */
      function animate() {
        requestAnimationFrame(animate);

        // Global rotation + scale
        rodGroup.rotation.set(
          parseFloat(rotXSlider.value),
          parseFloat(rotYSlider.value),
          parseFloat(rotZSlider.value)
        );
        rodGroup.scale.setScalar(parseFloat(scaleSlider.value));

        // Smooth letter blend
        const speedIn = 0.18;
        const speedOut = 0.12;
        const sp = (letterMixTarget > letterMix) ? speedIn : speedOut;
        letterMix += (letterMixTarget - letterMix) * sp;

        // Raycast
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(rods, false);

        const interactionAmount = parseFloat(interactionSlider.value);
        const spinOn = rodSpinSelect.value === 'on';

        for (let i = 0; i < rods.length; i++) {
          const rod = rods[i];

          rod.userData.hoverStrength *= 0.9;
          rod.userData.phase += 0.03;

          const hoverTravel = Math.sin(rod.userData.phase) * rod.userData.hoverStrength * interactionAmount;
          const m = (letterMask[i] || 0);
          const letterTravel = m * letterMix * LETTER_AMPLITUDE;

          rod.position.copy(rod.userData.basePosition);
          rod.position.y += (hoverTravel + letterTravel);

          if (spinOn) rod.rotation.y += 0.002;
        }

        if (intersects.length > 0) {
          const hovered = intersects[0].object;
          hovered.userData.hoverStrength += 0.4;

          if (hovered !== lastHovered) {
            playTone(hovered);
            lastHovered = hovered;
          }
        } else {
          lastHovered = null;
        }

        renderer.render(scene, camera);
      }

      animate();
    })();
  </script>
</body>
</html>
